// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: comment.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createComment = `-- name: CreateComment :one
INSERT INTO comments (
  product_id, 
  user_id, 
  content, 
  left_index,
  right_index,
  parent_id
) 
VALUES ($1, $2, $3, $4, $5 , $6) RETURNING id, product_id, user_id, content, left_index, right_index, parent_id, upadated_at, created_at
`

type CreateCommentParams struct {
	ProductID  uuid.UUID   `json:"product_id"`
	UserID     uuid.UUID   `json:"user_id"`
	Content    string      `json:"content"`
	LeftIndex  int64       `json:"left_index"`
	RightIndex int64       `json:"right_index"`
	ParentID   pgtype.UUID `json:"parent_id"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment,
		arg.ProductID,
		arg.UserID,
		arg.Content,
		arg.LeftIndex,
		arg.RightIndex,
		arg.ParentID,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.Content,
		&i.LeftIndex,
		&i.RightIndex,
		&i.ParentID,
		&i.UpadatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :many
DELETE FROM comments
WHERE (parent_id = $1 or id = $1 )and left_index >= $2 and right_index <= $3
RETURNING id, product_id, user_id, content, left_index, right_index, parent_id, upadated_at, created_at
`

type DeleteCommentParams struct {
	ParentID   pgtype.UUID `json:"parent_id"`
	LeftIndex  int64       `json:"left_index"`
	RightIndex int64       `json:"right_index"`
}

func (q *Queries) DeleteComment(ctx context.Context, arg DeleteCommentParams) ([]Comment, error) {
	rows, err := q.db.Query(ctx, deleteComment, arg.ParentID, arg.LeftIndex, arg.RightIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.UserID,
			&i.Content,
			&i.LeftIndex,
			&i.RightIndex,
			&i.ParentID,
			&i.UpadatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteCommentById = `-- name: DeleteCommentById :one
DELETE FROM comments
WHERE id = $1
RETURNING id, product_id, user_id, content, left_index, right_index, parent_id, upadated_at, created_at
`

func (q *Queries) DeleteCommentById(ctx context.Context, id uuid.UUID) (Comment, error) {
	row := q.db.QueryRow(ctx, deleteCommentById, id)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.Content,
		&i.LeftIndex,
		&i.RightIndex,
		&i.ParentID,
		&i.UpadatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAllComments = `-- name: GetAllComments :many
select id, product_id, user_id, content, left_index, right_index, parent_id, upadated_at, created_at from comments 
where (parent_id = $1 or id = $1) and left_index >= $2 and right_index <= $3
`

type GetAllCommentsParams struct {
	ParentID   pgtype.UUID `json:"parent_id"`
	LeftIndex  int64       `json:"left_index"`
	RightIndex int64       `json:"right_index"`
}

func (q *Queries) GetAllComments(ctx context.Context, arg GetAllCommentsParams) ([]Comment, error) {
	rows, err := q.db.Query(ctx, getAllComments, arg.ParentID, arg.LeftIndex, arg.RightIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.UserID,
			&i.Content,
			&i.LeftIndex,
			&i.RightIndex,
			&i.ParentID,
			&i.UpadatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentByID = `-- name: GetCommentByID :one
SELECT id, product_id, user_id, content, left_index, right_index, parent_id, upadated_at, created_at FROM comments
WHERE id = $1
`

func (q *Queries) GetCommentByID(ctx context.Context, id uuid.UUID) (Comment, error) {
	row := q.db.QueryRow(ctx, getCommentByID, id)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.Content,
		&i.LeftIndex,
		&i.RightIndex,
		&i.ParentID,
		&i.UpadatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getCommentByProductID = `-- name: GetCommentByProductID :many
SELECT id, product_id, user_id, content, left_index, right_index, parent_id, upadated_at, created_at FROM comments
WHERE product_id = $1
ORDER BY left_index ASC
`

func (q *Queries) GetCommentByProductID(ctx context.Context, productID uuid.UUID) ([]Comment, error) {
	rows, err := q.db.Query(ctx, getCommentByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.UserID,
			&i.Content,
			&i.LeftIndex,
			&i.RightIndex,
			&i.ParentID,
			&i.UpadatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentForUpdate = `-- name: GetCommentForUpdate :one
SELECT id, product_id, user_id, content, left_index, right_index, parent_id, upadated_at, created_at FROM comments
WHERE id = $1
FOR NO KEY UPDATE
`

func (q *Queries) GetCommentForUpdate(ctx context.Context, id uuid.UUID) (Comment, error) {
	row := q.db.QueryRow(ctx, getCommentForUpdate, id)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.Content,
		&i.LeftIndex,
		&i.RightIndex,
		&i.ParentID,
		&i.UpadatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getMaxRightIndex = `-- name: GetMaxRightIndex :one
SELECT MAX(right_index) as max_right_index 
FROM comments
WHERE parent_id = $1
`

func (q *Queries) GetMaxRightIndex(ctx context.Context, parentID pgtype.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getMaxRightIndex, parentID)
	var max_right_index interface{}
	err := row.Scan(&max_right_index)
	return max_right_index, err
}

const listComment = `-- name: ListComment :many
SELECT id, product_id, user_id, content, left_index, right_index, parent_id, upadated_at, created_at FROM comments 
WHERE product_id = $1 
AND left_index < $2 
AND right_index > $3 
ORDER BY left_index ASC
`

type ListCommentParams struct {
	ProductID  uuid.UUID `json:"product_id"`
	LeftIndex  int64     `json:"left_index"`
	RightIndex int64     `json:"right_index"`
}

func (q *Queries) ListComment(ctx context.Context, arg ListCommentParams) ([]Comment, error) {
	rows, err := q.db.Query(ctx, listComment, arg.ProductID, arg.LeftIndex, arg.RightIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.UserID,
			&i.Content,
			&i.LeftIndex,
			&i.RightIndex,
			&i.ParentID,
			&i.UpadatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateContentComment = `-- name: UpdateContentComment :one
UPDATE comments
SET content = $1
WHERE id = $2
RETURNING id, product_id, user_id, content, left_index, right_index, parent_id, upadated_at, created_at
`

type UpdateContentCommentParams struct {
	Content string    `json:"content"`
	ID      uuid.UUID `json:"id"`
}

func (q *Queries) UpdateContentComment(ctx context.Context, arg UpdateContentCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, updateContentComment, arg.Content, arg.ID)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.Content,
		&i.LeftIndex,
		&i.RightIndex,
		&i.ParentID,
		&i.UpadatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateLeftIndexComment = `-- name: UpdateLeftIndexComment :many
UPDATE comments
SET left_index = left_index + $3
WHERE (parent_id = $1 or id = $1) and left_index > $2
RETURNING id, product_id, user_id, content, left_index, right_index, parent_id, upadated_at, created_at
`

type UpdateLeftIndexCommentParams struct {
	ParentID    pgtype.UUID `json:"parent_id"`
	LeftIndex   int64       `json:"left_index"`
	LeftIndex_2 int64       `json:"left_index_2"`
}

func (q *Queries) UpdateLeftIndexComment(ctx context.Context, arg UpdateLeftIndexCommentParams) ([]Comment, error) {
	rows, err := q.db.Query(ctx, updateLeftIndexComment, arg.ParentID, arg.LeftIndex, arg.LeftIndex_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.UserID,
			&i.Content,
			&i.LeftIndex,
			&i.RightIndex,
			&i.ParentID,
			&i.UpadatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRightIndexComment = `-- name: UpdateRightIndexComment :many
UPDATE comments
SET right_index = right_index + $3
WHERE (parent_id = $1 or id = $1) and right_index >= $2
RETURNING id, product_id, user_id, content, left_index, right_index, parent_id, upadated_at, created_at
`

type UpdateRightIndexCommentParams struct {
	ParentID     pgtype.UUID `json:"parent_id"`
	RightIndex   int64       `json:"right_index"`
	RightIndex_2 int64       `json:"right_index_2"`
}

func (q *Queries) UpdateRightIndexComment(ctx context.Context, arg UpdateRightIndexCommentParams) ([]Comment, error) {
	rows, err := q.db.Query(ctx, updateRightIndexComment, arg.ParentID, arg.RightIndex, arg.RightIndex_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.UserID,
			&i.Content,
			&i.LeftIndex,
			&i.RightIndex,
			&i.ParentID,
			&i.UpadatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
