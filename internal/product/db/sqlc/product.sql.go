// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: product.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
  id_category,
  id_account,
  name,
  description,
  brand_name,
  price,
  inventory
) VALUES (
  $1, $2, $3, $4, $5, $6 , $7
) RETURNING id, id_category, id_account, name, description, brand_name, price, inventory, updated_at, created_at
`

type CreateProductParams struct {
	IDCategory  uuid.UUID `json:"id_category"`
	IDAccount   uuid.UUID `json:"id_account"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	BrandName   string    `json:"brand_name"`
	Price       int64     `json:"price"`
	Inventory   int64     `json:"inventory"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.IDCategory,
		arg.IDAccount,
		arg.Name,
		arg.Description,
		arg.BrandName,
		arg.Price,
		arg.Inventory,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.IDCategory,
		&i.IDAccount,
		&i.Name,
		&i.Description,
		&i.BrandName,
		&i.Price,
		&i.Inventory,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :one
DELETE FROM products WHERE id = $1 RETURNING id, id_category, id_account, name, description, brand_name, price, inventory, updated_at, created_at
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, deleteProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.IDCategory,
		&i.IDAccount,
		&i.Name,
		&i.Description,
		&i.BrandName,
		&i.Price,
		&i.Inventory,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, id_category, id_account, name, description, brand_name, price, inventory, updated_at, created_at FROM products WHERE id = $1
`

func (q *Queries) GetProductByID(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.IDCategory,
		&i.IDAccount,
		&i.Name,
		&i.Description,
		&i.BrandName,
		&i.Price,
		&i.Inventory,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getProductCategory = `-- name: GetProductCategory :many
SELECT products.id, id_category, id_account, products.name, products.description, brand_name, price, inventory, products.updated_at, products.created_at, categories.id, categories.name, categories.description, categories.updated_at, categories.created_at FROM products JOIN categories ON products.id_category = categories.id WHERE categories.name = $1
`

type GetProductCategoryRow struct {
	ID            uuid.UUID `json:"id"`
	IDCategory    uuid.UUID `json:"id_category"`
	IDAccount     uuid.UUID `json:"id_account"`
	Name          string    `json:"name"`
	Description   string    `json:"description"`
	BrandName     string    `json:"brand_name"`
	Price         int64     `json:"price"`
	Inventory     int64     `json:"inventory"`
	UpdatedAt     time.Time `json:"updated_at"`
	CreatedAt     time.Time `json:"created_at"`
	ID_2          uuid.UUID `json:"id_2"`
	Name_2        string    `json:"name_2"`
	Description_2 string    `json:"description_2"`
	UpdatedAt_2   time.Time `json:"updated_at_2"`
	CreatedAt_2   time.Time `json:"created_at_2"`
}

func (q *Queries) GetProductCategory(ctx context.Context, name string) ([]GetProductCategoryRow, error) {
	rows, err := q.db.Query(ctx, getProductCategory, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductCategoryRow
	for rows.Next() {
		var i GetProductCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.IDCategory,
			&i.IDAccount,
			&i.Name,
			&i.Description,
			&i.BrandName,
			&i.Price,
			&i.Inventory,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.ID_2,
			&i.Name_2,
			&i.Description_2,
			&i.UpdatedAt_2,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductForUpdate = `-- name: GetProductForUpdate :one
SELECT id, id_category, id_account, name, description, brand_name, price, inventory, updated_at, created_at FROM products WHERE id = $1 LIMIT 1 FOR UPDATE
`

func (q *Queries) GetProductForUpdate(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProductForUpdate, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.IDCategory,
		&i.IDAccount,
		&i.Name,
		&i.Description,
		&i.BrandName,
		&i.Price,
		&i.Inventory,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getProductInventory = `-- name: GetProductInventory :one
SELECT id,inventory FROM products WHERE id = $1
`

type GetProductInventoryRow struct {
	ID        uuid.UUID `json:"id"`
	Inventory int64     `json:"inventory"`
}

func (q *Queries) GetProductInventory(ctx context.Context, id uuid.UUID) (GetProductInventoryRow, error) {
	row := q.db.QueryRow(ctx, getProductInventory, id)
	var i GetProductInventoryRow
	err := row.Scan(&i.ID, &i.Inventory)
	return i, err
}

const listProducts = `-- name: ListProducts :many
SELECT id, id_category, id_account, name, description, brand_name, price, inventory, updated_at, created_at FROM products ORDER BY id OFFSET $1 LIMIT $2
`

type ListProductsParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.IDCategory,
			&i.IDAccount,
			&i.Name,
			&i.Description,
			&i.BrandName,
			&i.Price,
			&i.Inventory,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upadateProduct = `-- name: UpadateProduct :one
UPDATE products
SET
  id_category = COALESCE($1, id_category),
  name = COALESCE($2, name),
  description = COALESCE($3, description),
  brand_name = COALESCE($4, brand_name),
  price = COALESCE($5, price),
  inventory = COALESCE($6, inventory),
  updated_at = now()
WHERE
  id = $7
RETURNING id, id_category, id_account, name, description, brand_name, price, inventory, updated_at, created_at
`

type UpadateProductParams struct {
	IDCategory  pgtype.UUID `json:"id_category"`
	Name        pgtype.Text `json:"name"`
	Description pgtype.Text `json:"description"`
	BrandName   pgtype.Text `json:"brand_name"`
	Price       pgtype.Int8 `json:"price"`
	Inventory   pgtype.Int8 `json:"inventory"`
	ID          uuid.UUID   `json:"id"`
}

func (q *Queries) UpadateProduct(ctx context.Context, arg UpadateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, upadateProduct,
		arg.IDCategory,
		arg.Name,
		arg.Description,
		arg.BrandName,
		arg.Price,
		arg.Inventory,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.IDCategory,
		&i.IDAccount,
		&i.Name,
		&i.Description,
		&i.BrandName,
		&i.Price,
		&i.Inventory,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateProductInventory = `-- name: UpdateProductInventory :one
UPDATE products
SET
  inventory = inventory + $2
WHERE
  id = $1
RETURNING id, id_category, id_account, name, description, brand_name, price, inventory, updated_at, created_at
`

type UpdateProductInventoryParams struct {
	ID        uuid.UUID `json:"id"`
	Inventory int64     `json:"inventory"`
}

func (q *Queries) UpdateProductInventory(ctx context.Context, arg UpdateProductInventoryParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProductInventory, arg.ID, arg.Inventory)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.IDCategory,
		&i.IDAccount,
		&i.Name,
		&i.Description,
		&i.BrandName,
		&i.Price,
		&i.Inventory,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
